/* eslint-disable no-useless-escape */

const fs = require('fs-extra');
const path = require('path');
const os = require('os');

class HookGenerator {
  constructor() {
    this.hooksDir = path.join(os.homedir(), '.claude', 'hooks');
    this.hookFile = path.join(this.hooksDir, 'claude-code-companion-hook.js');
  }

  /**
   * Generate and save the Claude Code hook file
   */
  async generateHook() {
    // Ensure hooks directory exists
    await fs.ensureDir(this.hooksDir);

    // Generate hook content
    const hookContent = this._generateHookContent();

    // Write hook file
    await fs.writeFile(this.hookFile, hookContent);
    
    // Make executable
    await fs.chmod(this.hookFile, '755');

    return this.hookFile;
  }

  /**
   * Generate the hook file content
   */
  _generateHookContent() {
    return `#!/usr/bin/env node

/**
 * Claude Code Companion Hook
 * Generated by claude-code-companion npm package v${this.getPackageVersion()}
 * 
 * This hook intercepts Claude Code operations and sends notifications
 * to your iPhone for approval on risky operations.
 */

const https = require('https');
const http = require('http');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Configuration
const CONFIG = {
  deviceId: process.env.CC_NOTIFICATIONS_DEVICE_ID,
  serverUrl: process.env.CC_NOTIFICATIONS_SERVER || 'https://claude-code-companion-backend-production.up.railway.app',
  sandboxUrl: 'https://claude-code-companion-backend-develop.up.railway.app',
  timeout: parseInt(process.env.CC_NOTIFICATIONS_TIMEOUT) || 30000,
  pollInterval: parseInt(process.env.CC_NOTIFICATIONS_POLL_INTERVAL) || 2000,
  configFile: path.join(os.homedir(), '.claude-code-companion')
};

// Load device ID and server URL from config file if not in environment
if (fs.existsSync(CONFIG.configFile)) {
  try {
    const config = JSON.parse(fs.readFileSync(CONFIG.configFile, 'utf8'));
    CONFIG.deviceId = CONFIG.deviceId || config.deviceId;
    // Use the server URL from config file (which includes sandbox detection)
    CONFIG.serverUrl = process.env.CC_NOTIFICATIONS_SERVER || config.serverUrl || CONFIG.serverUrl;
  } catch (error) {
    // Ignore config file errors
  }
}

/**
 * Risk assessment patterns
 */
const RISK_PATTERNS = {
  high: [
    /rm\s+-rf/i,
    /sudo/i,
    /DELETE\s+FROM/i,
    /DROP\s+TABLE/i,
    /DROP\s+DATABASE/i,
    /\.(env|config|key|pem|p12|pfx)$/i,
    /config\.json$/i,
    /package\.json$/i,
    /secret/i,
    /password/i,
    /token/i,
    /api[_-]?key/i,
    /chmod\s+777/i,
    />\\/dev\\/null/i,
    /format\s+.*:/i,
    /shutdown/i,
    /reboot/i,
    /kill\s+-9/i
  ],
  medium: [
    /rm\s+[^-]/i,
    /mv\s+.*\.(json|js|py|rb|php|go)$/i,
    /chmod/i,
    /chown/i,
    /mkdir\s+-p/i,
    /UPDATE\s+.*SET/i,
    /ALTER\s+TABLE/i,
    /TRUNCATE/i,
    /npm\s+install/i,
    /pip\s+install/i,
    /composer\s+install/i,
    /yarn\s+add/i,
    />>/i
  ]
};

/**
 * Assess risk level of an operation
 */
function assessRiskLevel(operation) {
  const text = operation.toLowerCase();
  
  // Check high risk patterns
  if (RISK_PATTERNS.high.some(pattern => pattern.test(text))) {
    return 'high';
  }
  
  // Check medium risk patterns  
  if (RISK_PATTERNS.medium.some(pattern => pattern.test(text))) {
    return 'medium';
  }
  
  return 'low';
}

/**
 * Map operation type to action type
 */
function mapOperationType(operation) {
  const text = operation.toLowerCase();
  
  if (text.includes('delete') || text.includes('rm ')) return 'delete';
  if (text.includes('modify') || text.includes('edit')) return 'modify';
  if (text.includes('create') || text.includes('mkdir')) return 'create';
  if (text.includes('install') || text.includes('add')) return 'install';
  if (text.includes('run') || text.includes('execute')) return 'execute';
  if (text.includes('move') || text.includes('mv ')) return 'move';
  if (text.includes('copy') || text.includes('cp ')) return 'copy';
  
  return 'other';
}

/**
 * Make HTTP request
 */
function makeRequest(method, path, data = null) {
  return new Promise((resolve, reject) => {
    try {
      const url = new URL(CONFIG.serverUrl + path);
      const isHttps = url.protocol === 'https:';
      const lib = isHttps ? https : http;
      
      const options = {
        hostname: url.hostname,
        port: url.port || (isHttps ? 443 : 80),
        path: url.pathname + url.search,
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'Claude-Code-Hook/1.0'
        },
        timeout: CONFIG.timeout
      };

      const req = lib.request(options, (res) => {
        let body = '';
        res.on('data', chunk => body += chunk);
        res.on('end', () => {
          try {
            if (!body.trim()) {
              resolve({ success: true });
              return;
            }
            
            const response = JSON.parse(body);
            
            if (res.statusCode >= 400) {
              reject(new Error(response.error || \`HTTP \${res.statusCode}\`));
              return;
            }
            
            resolve(response);
          } catch (error) {
            reject(new Error(\`Invalid JSON response: \${body}\`));
          }
        });
      });

      req.on('error', (error) => {
        if (error.code === 'ECONNREFUSED') {
          reject(new Error('Backend server not running'));
        } else if (error.code === 'ETIMEDOUT') {
          reject(new Error('Request timeout'));
        } else {
          reject(new Error(\`Network error: \${error.message}\`));
        }
      });
      
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Request timeout'));
      });

      if (data) {
        req.write(JSON.stringify(data));
      }
      
      req.end();
    } catch (error) {
      reject(new Error(\`Request setup failed: \${error.message}\`));
    }
  });
}

/**
 * Poll for user response
 */
async function pollForResponse(requestId) {
  const maxAttempts = Math.floor(CONFIG.timeout / CONFIG.pollInterval);
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const response = await makeRequest('GET', \`/api/requests/\${requestId}\`);
      
      if (response.success && response.status !== 'pending') {
        // Handle multi-option responses
        if (response.user_response && response.user_response.startsWith('option_')) {
          return {
            approved: true,
            denied: false,
            expired: false,
            response: response.user_response,
            selectedOption: response.selected_option_index,
            status: response.status
          };
        }
        
        return {
          approved: response.status === 'responded' && response.user_response === 'approved',
          denied: response.status === 'responded' && response.user_response === 'denied',
          expired: response.status === 'expired',
          response: response.user_response,
          status: response.status
        };
      }
      
      // Wait before next poll
      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.pollInterval));
      }
      
    } catch (error) {
      // Continue polling on individual request failures
      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.pollInterval));
      }
    }
  }
  
  // Timeout reached
  return {
    approved: false,
    denied: true,
    expired: true,
    response: 'timeout',
    status: 'timeout'
  };
}

/**
 * Parse Claude Code options from input text
 */
function parseClaudeCodeOptions(input) {
  // Match numbered options like "1. Yes" or "2. Yes, allow reading..."
  const optionRegex = /^\s*(\d+)\.\s*(.+)$/gm;
  const matches = [...input.matchAll(optionRegex)];
  
  if (matches.length === 0) {
    return [];
  }
  
  return matches.map(([_, index, text]) => ({
    index: parseInt(index) - 1,
    text: text.trim(),
    value: \`option_\${index}\`
  }));
}

/**
 * Send notification request
 */
async function sendNotificationRequest(operation) {
  if (!CONFIG.deviceId) {
    throw new Error('Device ID not configured - run: cccompanion pair <code>');
  }

  const riskLevel = assessRiskLevel(operation);
  const options = parseClaudeCodeOptions(operation);
  
  // Default multi-option behavior: always send structured notifications
  const shouldAutoApprove = riskLevel === 'low' && options.length === 0;
  
  const requestData = {
    device_id: CONFIG.deviceId,
    action_type: mapOperationType(operation),
    action_description: operation,
    risk_level: riskLevel,
    auto_approve: shouldAutoApprove,
    options: options,  // Always send options array (empty if none)
    notification_type: riskLevel === 'low' ? 'informational' : 'blocking',
    context: {
      timestamp: new Date().toISOString(),
      cwd: process.cwd(),
      user: os.userInfo().username,
      hostname: os.hostname()
    }
  };

  try {
    const response = await makeRequest('POST', '/api/requests', requestData);
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to send notification');
    }

    // Auto-approve low-risk operations after short delay for monitoring
    if (shouldAutoApprove) {
      console.log(\`ðŸ“± Monitoring: \${operation} (auto-approved)\`);
      await new Promise(resolve => setTimeout(resolve, 1000));
      return { approved: true, monitored: true };
    }

    // Wait for user interaction - all notifications now support multi-option
    return await pollForResponse(response.request_id);
    
  } catch (error) {
    // Log error for debugging but don't block operation
    console.error('Claude Code Notifications Error:', error.message);
    
    // In case of error, default to denying the operation for safety
    return {
      approved: false,
      denied: true,
      error: error.message,
      status: 'error'
    };
  }
}

/**
 * Read JSON input from stdin
 */
function readStdinAsJson() {
  return new Promise((resolve, reject) => {
    let input = '';
    
    process.stdin.setEncoding('utf8');
    
    process.stdin.on('data', chunk => {
      input += chunk;
    });
    
    process.stdin.on('end', () => {
      try {
        if (input.trim()) {
          resolve(JSON.parse(input));
        } else {
          resolve(null);
        }
      } catch (error) {
        reject(new Error(\`Invalid JSON input: \${error.message}\`));
      }
    });
    
    process.stdin.on('error', error => {
      reject(error);
    });
  });
}

/**
 * Main hook function
 */
async function main() {
  try {
    // Try to read JSON input from stdin (Notification hook format)
    let hookInput = null;
    try {
      hookInput = await readStdinAsJson();
    } catch (error) {
      // If no valid JSON input, fall back to command line arguments
      console.log('No JSON input received, using command line arguments');
    }
    
    let operation;
    if (hookInput && hookInput.message) {
      // Extract operation from notification message
      operation = hookInput.message;
      console.log(\`Processing notification: \${operation}\`);
    } else {
      // Fall back to command line arguments
      operation = process.argv.slice(2).join(' ') || 'Unknown operation';
      console.log(\`Processing command: \${operation}\`);
    }
    
    // Send notification and wait for response
    const result = await sendNotificationRequest(operation);
    
    if (result.monitored) {
      console.log('Operation approved (low risk, monitored)');
      process.exit(0);
    } else if (result.approved) {
      if (result.selectedOption !== undefined) {
        console.log(\`User selected option \${result.selectedOption + 1}: \${result.response}\`);
      } else {
        console.log(\`Operation approved by user: \${result.response || 'approved'}\`);
      }
      process.exit(0);
    } else {
      console.log(\`Operation denied by user: \${result.response || 'denied'}\`);
      process.exit(1);
    }
    
  } catch (error) {
    console.error('Hook execution failed:', error.message);
    
    // Default to denying for safety
    console.log('Operation denied due to hook error');
    process.exit(1);
  }
}

// Execute if called directly
if (require.main === module) {
  main();
}

module.exports = { sendNotificationRequest, assessRiskLevel };
`;
  }

  /**
   * Get hook file path
   */
  getHookPath() {
    return this.hookFile;
  }

  /**
   * Check if hook file exists
   */
  hookExists() {
    return fs.existsSync(this.hookFile);
  }

  /**
   * Remove hook file
   */
  async removeHook() {
    if (this.hookExists()) {
      await fs.unlink(this.hookFile);
      return true;
    }
    return false;
  }

  /**
   * Update hook file
   */
  async updateHook() {
    return await this.generateHook();
  }

  /**
   * Get package version from package.json
   */
  getPackageVersion() {
    try {
      const packagePath = path.join(__dirname, '..', '..', 'package.json');
      const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      return pkg.version;
    } catch (error) {
      return '1.0.11'; // fallback version
    }
  }

  /**
   * Check if hook file needs updating
   */
  async needsUpdate() {
    if (!this.hookExists()) {
      return true; // Hook doesn't exist, needs creation
    }

    try {
      const currentContent = await fs.readFile(this.hookFile, 'utf8');
      const currentVersion = this.getPackageVersion();
      
      // Check if the hook contains the current version
      const versionRegex = /Generated by claude-code-companion npm package v([\d.]+)/;
      const match = currentContent.match(versionRegex);
      
      if (!match) {
        return true; // No version found, needs update
      }
      
      const hookVersion = match[1];
      return hookVersion !== currentVersion;
      
    } catch (error) {
      return true; // Error reading file, assume needs update
    }
  }
}

// Export singleton instance
module.exports = new HookGenerator();