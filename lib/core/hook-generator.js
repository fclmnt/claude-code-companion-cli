const fs = require('fs-extra');
const path = require('path');
const os = require('os');

class HookGenerator {
  constructor() {
    this.hooksDir = path.join(os.homedir(), '.claude', 'hooks');
    this.hookFile = path.join(this.hooksDir, 'claude-code-companion-hook.js');
  }

  /**
   * Generate and save the Claude Code hook file
   */
  async generateHook() {
    // Ensure hooks directory exists
    await fs.ensureDir(this.hooksDir);

    // Generate hook content
    const hookContent = this._generateHookContent();

    // Write hook file
    await fs.writeFile(this.hookFile, hookContent);
    
    // Make executable
    await fs.chmod(this.hookFile, '755');

    return this.hookFile;
  }

  /**
   * Generate the hook file content
   */
  _generateHookContent() {
    return `#!/usr/bin/env node

/**
 * Claude Code Companion Hook
 * Generated by claude-code-companion npm package
 * 
 * This hook intercepts Claude Code operations and sends notifications
 * to your iPhone for approval on risky operations.
 */

const https = require('https');
const http = require('http');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Configuration
const CONFIG = {
  deviceId: process.env.CC_NOTIFICATIONS_DEVICE_ID,
  serverUrl: process.env.CC_NOTIFICATIONS_SERVER || 'https://claude-code-companion-backend-production.up.railway.app',
  timeout: parseInt(process.env.CC_NOTIFICATIONS_TIMEOUT) || 30000,
  pollInterval: parseInt(process.env.CC_NOTIFICATIONS_POLL_INTERVAL) || 2000,
  configFile: path.join(os.homedir(), '.claude-code-companion')
};

// Load device ID from config file if not in environment
if (!CONFIG.deviceId && fs.existsSync(CONFIG.configFile)) {
  try {
    const config = JSON.parse(fs.readFileSync(CONFIG.configFile, 'utf8'));
    CONFIG.deviceId = config.deviceId;
    CONFIG.serverUrl = config.serverUrl || CONFIG.serverUrl;
  } catch (error) {
    // Ignore config file errors
  }
}

/**
 * Risk assessment patterns
 */
const RISK_PATTERNS = {
  high: [
    /rm\\s+-rf/i,
    /sudo/i,
    /DELETE\\s+FROM/i,
    /DROP\\s+TABLE/i,
    /DROP\\s+DATABASE/i,
    /\\.(env|config|key|pem|p12|pfx)$/i,
    /config\\.json$/i,
    /package\\.json$/i,
    /secret/i,
    /password/i,
    /token/i,
    /api[_-]?key/i,
    /chmod\\s+777/i,
    />/dev/null/i,
    /format\\s+.*:/i,
    /shutdown/i,
    /reboot/i,
    /kill\\s+-9/i
  ],
  medium: [
    /rm\\s+[^-]/i,
    /mv\\s+.*\\.(json|js|py|rb|php|go)$/i,
    /chmod/i,
    /chown/i,
    /mkdir\\s+-p/i,
    /UPDATE\\s+.*SET/i,
    /ALTER\\s+TABLE/i,
    /TRUNCATE/i,
    /npm\\s+install/i,
    /pip\\s+install/i,
    /composer\\s+install/i,
    /yarn\\s+add/i,
    />>/i
  ]
};

/**
 * Assess risk level of an operation
 */
function assessRiskLevel(operation) {
  const text = operation.toLowerCase();
  
  // Check high risk patterns
  if (RISK_PATTERNS.high.some(pattern => pattern.test(text))) {
    return 'high';
  }
  
  // Check medium risk patterns  
  if (RISK_PATTERNS.medium.some(pattern => pattern.test(text))) {
    return 'medium';
  }
  
  return 'low';
}

/**
 * Map operation type to action type
 */
function mapOperationType(operation) {
  const text = operation.toLowerCase();
  
  if (text.includes('delete') || text.includes('rm ')) return 'delete';
  if (text.includes('modify') || text.includes('edit')) return 'modify';
  if (text.includes('create') || text.includes('mkdir')) return 'create';
  if (text.includes('install') || text.includes('add')) return 'install';
  if (text.includes('run') || text.includes('execute')) return 'execute';
  if (text.includes('move') || text.includes('mv ')) return 'move';
  if (text.includes('copy') || text.includes('cp ')) return 'copy';
  
  return 'other';
}

/**
 * Make HTTP request
 */
function makeRequest(method, path, data = null) {
  return new Promise((resolve, reject) => {
    try {
      const url = new URL(CONFIG.serverUrl + path);
      const isHttps = url.protocol === 'https:';
      const lib = isHttps ? https : http;
      
      const options = {
        hostname: url.hostname,
        port: url.port || (isHttps ? 443 : 80),
        path: url.pathname + url.search,
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'Claude-Code-Hook/1.0'
        },
        timeout: CONFIG.timeout
      };

      const req = lib.request(options, (res) => {
        let body = '';
        res.on('data', chunk => body += chunk);
        res.on('end', () => {
          try {
            if (!body.trim()) {
              resolve({ success: true });
              return;
            }
            
            const response = JSON.parse(body);
            
            if (res.statusCode >= 400) {
              reject(new Error(response.error || \`HTTP \${res.statusCode}\`));
              return;
            }
            
            resolve(response);
          } catch (error) {
            reject(new Error(\`Invalid JSON response: \${body}\`));
          }
        });
      });

      req.on('error', (error) => {
        if (error.code === 'ECONNREFUSED') {
          reject(new Error('Backend server not running'));
        } else if (error.code === 'ETIMEDOUT') {
          reject(new Error('Request timeout'));
        } else {
          reject(new Error(\`Network error: \${error.message}\`));
        }
      });
      
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Request timeout'));
      });

      if (data) {
        req.write(JSON.stringify(data));
      }
      
      req.end();
    } catch (error) {
      reject(new Error(\`Request setup failed: \${error.message}\`));
    }
  });
}

/**
 * Poll for user response
 */
async function pollForResponse(requestId) {
  const maxAttempts = Math.floor(CONFIG.timeout / CONFIG.pollInterval);
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const response = await makeRequest('GET', \`/api/notifications/\${requestId}/status\`);
      
      if (response.success && response.status !== 'pending') {
        return {
          approved: response.status === 'approved',
          denied: response.status === 'denied',
          expired: response.status === 'expired',
          response: response.user_response,
          status: response.status
        };
      }
      
      // Wait before next poll
      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.pollInterval));
      }
      
    } catch (error) {
      // Continue polling on individual request failures
      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.pollInterval));
      }
    }
  }
  
  // Timeout reached
  return {
    approved: false,
    denied: true,
    expired: true,
    response: 'timeout',
    status: 'timeout'
  };
}

/**
 * Send notification request
 */
async function sendNotificationRequest(operation) {
  if (!CONFIG.deviceId) {
    throw new Error('Device ID not configured - run: cccompanion pair <code>');
  }

  const riskLevel = assessRiskLevel(operation);
  
  // Skip notifications for low-risk operations in production
  if (riskLevel === 'low' && process.env.NODE_ENV !== 'development') {
    return { approved: true, skipped: true };
  }
  
  const requestData = {
    device_id: CONFIG.deviceId,
    action_type: mapOperationType(operation),
    action_description: operation,
    risk_level: riskLevel,
    context: {
      timestamp: new Date().toISOString(),
      cwd: process.cwd(),
      user: os.userInfo().username,
      hostname: os.hostname()
    }
  };

  try {
    const response = await makeRequest('POST', '/api/notifications', requestData);
    
    if (!response.success) {
      throw new Error(response.error || 'Failed to send notification');
    }

    return await pollForResponse(response.request_id);
    
  } catch (error) {
    // Log error for debugging but don't block operation
    console.error('Claude Code Notifications Error:', error.message);
    
    // In case of error, default to denying the operation for safety
    return {
      approved: false,
      denied: true,
      error: error.message,
      status: 'error'
    };
  }
}

/**
 * Read JSON input from stdin
 */
function readStdinAsJson() {
  return new Promise((resolve, reject) => {
    let input = '';
    
    process.stdin.setEncoding('utf8');
    
    process.stdin.on('data', chunk => {
      input += chunk;
    });
    
    process.stdin.on('end', () => {
      try {
        if (input.trim()) {
          resolve(JSON.parse(input));
        } else {
          resolve(null);
        }
      } catch (error) {
        reject(new Error(\`Invalid JSON input: \${error.message}\`));
      }
    });
    
    process.stdin.on('error', error => {
      reject(error);
    });
  });
}

/**
 * Main hook function
 */
async function main() {
  try {
    // Try to read JSON input from stdin (Notification hook format)
    let hookInput = null;
    try {
      hookInput = await readStdinAsJson();
    } catch (error) {
      // If no valid JSON input, fall back to command line arguments
      console.log('No JSON input received, using command line arguments');
    }
    
    let operation;
    if (hookInput && hookInput.message) {
      // Extract operation from notification message
      operation = hookInput.message;
      console.log(\`Processing notification: \${operation}\`);
    } else {
      // Fall back to command line arguments
      operation = process.argv.slice(2).join(' ') || 'Unknown operation';
      console.log(\`Processing command: \${operation}\`);
    }
    
    // Send notification and wait for response
    const result = await sendNotificationRequest(operation);
    
    if (result.skipped) {
      console.log('Operation approved (low risk, skipped notification)');
      process.exit(0);
    } else if (result.approved) {
      console.log(\`Operation approved by user: \${result.response || 'approved'}\`);
      process.exit(0);
    } else {
      console.log(\`Operation denied by user: \${result.response || 'denied'}\`);
      process.exit(1);
    }
    
  } catch (error) {
    console.error('Hook execution failed:', error.message);
    
    // Default to denying for safety
    console.log('Operation denied due to hook error');
    process.exit(1);
  }
}

// Execute if called directly
if (require.main === module) {
  main();
}

module.exports = { sendNotificationRequest, assessRiskLevel };
`;
  }

  /**
   * Get hook file path
   */
  getHookPath() {
    return this.hookFile;
  }

  /**
   * Check if hook file exists
   */
  hookExists() {
    return fs.existsSync(this.hookFile);
  }

  /**
   * Remove hook file
   */
  async removeHook() {
    if (this.hookExists()) {
      await fs.unlink(this.hookFile);
      return true;
    }
    return false;
  }

  /**
   * Update hook file
   */
  async updateHook() {
    return await this.generateHook();
  }
}

// Export singleton instance
module.exports = new HookGenerator();